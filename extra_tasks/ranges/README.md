## Ranges

В данном задании требуется реализовать свою библиотеку [ranges](https://en.cppreference.com/w/cpp/ranges).

Все объекты можно разбить на два типа:
* View - отображения, по которым можно итерироваться.
* Adaptor - функции над view

Данное разбиение позволяет строить цепочки вида: $Adaptor_1(Adaptor_2(... Adaptor_N(view)))$.

Однако данное представление сложно читается и удобнее описывать эти вызовы в обратном порядке:
```
view | Adaptor_N | ... | Adaptor_2 | Adaptor_1
```

Те аргумент находится слева, а функция применяемая к нему справа и разделяются они между собой с помощью `|`.

### Views

В данной задаче требуется реализовать [не владеющие view](https://en.cppreference.com/w/cpp/ranges/ref_view). Данные view не хранят весь контейнер по которому итерируются, а только ссылаются на него. Это позволяет избежать лишних копирований, но накладывает ряд ограничений на время жизни самого контейнера.

Требования к view:
* методы begin/end - позволяет итерироваться по коллекции, достаточно гарантий forward_iterator'a
* `operator|(adaptor)` - возвращает новую view после применения adaptor'a

В данной задаче потребуется реализовать два способа конструирования view:
* `Empty<T>` - возвращает пустую view с данным типом
* `View<Container>` - не владеющая view над произвольным контейнером с данными, имеющим методы begin и end

### Adaptors

Адапторы позволяют описывать ленивые вычислений, которые будут происходить только по мере необходимости в момент итерации.

> Данный [подход](https://wiki.haskell.org/Lazy_evaluation) распространен в функциональном программировании.

Требования к адаптору:
* Должен иметь метод, который будет вызываться в operator| у view

Нужно поддержать следующие адапторы:
* `First(n)` - итерируется только по первым n элементам
* `Filter(filter)` - итерируется только по элементам удовлетворяющим условию filter
* `Map(mapper)` - пребразовывает элементы с помощью mapper и возвращает новые значения.
* `To<Container>` - перекладывает значения в контейнер и возвращает его, является терминальным адаптором
* `SafeMap(mapper)` - аналогично Map, только возвращаемое значение является std::optional и значение не определено, если mapper кидает исключение
* `Unwrap` - распаковывает только определенные std::optional и возвращает лежащие там значения

Во избежание копирования кода, подумайте как можно выразить последние два адаптора через остальные.

**Примерчение**
* Использование стандартной библиотеки ranges запрещено
